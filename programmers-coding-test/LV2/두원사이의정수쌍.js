/**
 * 문제 설명
 * r2 > r1인 두 자연수 r1, r2가 매개변수로 주어집니다.
 * r1과 r2는 각각 한 원의 반지름 길이를 나타냅니다.
 * r2원에는 속하고 r1 영역에는 속하지 않는(도넛 모양 영역의) 정수 좌표의 개수를 return 하도록 solution 함수를 완성해주세요.
 * @param number r1 1보다 큰 자연수
 * @param number r2 r1보다 큰 자연수
 * @returns 
 * 테스트 1 〉	통과 (0.07ms, 33.3MB)
테스트 2 〉	통과 (0.17ms, 33.3MB)
테스트 3 〉	통과 (0.21ms, 33.4MB)
테스트 4 〉	통과 (0.39ms, 33.5MB)
테스트 5 〉	통과 (0.28ms, 33.5MB)
테스트 6 〉	통과 (0.53ms, 33.4MB)
테스트 7 〉	통과 (8.87ms, 37.7MB)
테스트 8 〉	통과 (16.23ms, 37.7MB)
테스트 9 〉	통과 (9.38ms, 37.8MB)
테스트 10 〉	통과 (11.83ms, 37.8MB)
생각해보니 1사분면에서 x를 1씩 증가시키면서 r2원 위의 점의 y값을 구하고
해당 y값과 r1원 위의 점의 y값을 비교해서 그 사이의 정수값 갯수만 구하면 됨. 
드디어 성공! 마지막에 최소y 구하는 코드가 이상하게 들어가있었네!
 * 오래 걸린 결정적 이유: 점 하나하나마다 원점으로부터의 거리를 계산해서 조건에 해당하는지 찾아야한다 생각해서 시간초과에 걸림
 */
function solution(r1, r2) {
  let answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  answer = (r2 - r1 + 1) * 4; // x축 y축 위에 있는 해당 점들은 먼저 더해놓기
  // 4개분면 대칭이므로 1사분면에 위치한 점들 수를 구한 뒤 x4
  let 일사분면 = 0;
  let 최대y = 0;
  let 최소y = 0;
  for (let x = 1; x < r2; x++) {
    // r2 원 위에 있는 점의 y좌표를 구한 뒤 내림하여 그보다 작은 최대정수 y값 계산
    최대y = Math.floor(Math.sqrt(Math.pow(r2, 2) - Math.pow(x, 2)));
    if (x >= r1) {
      // x가 r1보다 크면 1부터 최대y값까지 다 해당되므로 최소y값 구할 필요 없음
      일사분면 += 최대y;
    } else {
      // r1 원 위에 있는 점의 y좌표를 구한 뒤 올림하여 가능한 최소 정수 y값을 계산
      최소y = Math.ceil(Math.sqrt(Math.pow(r1, 2) - Math.pow(x, 2)));
      일사분면 += 최대y - 최소y + 1;
    }
  }

  answer += 일사분면 * 4;

  return answer;
}

// 이 풀이에서는 굳이 x축, y축 위의 점들을 먼저 구해놓을 필요가 없는 점을 개선한 version
function solution(r1, r2) {
  let answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  let 일사분면 = 0;
  let 최대y = 0;
  let 최소y = 0;
  for (let x = 1; x <= r2; x++) {
    // r2 원 위에 있는 점의 y좌표를 구한 뒤 내림하여 그보다 작은 최대정수 y값 계산
    최대y = Math.floor(Math.sqrt(Math.pow(r2, 2) - Math.pow(x, 2)));
    if (x >= r1) {
      // x가 r1보다 크거나 같으면 0부터 최대y값까지 다 해당되므로 최소y값 구할 필요 없음
      일사분면 += 최대y + 1;
    } else {
      // r1 원 위에 있는 점의 y좌표를 구한 뒤 올림하여 가능한 최소 정수 y값을 계산
      최소y = Math.ceil(Math.sqrt(Math.pow(r1, 2) - Math.pow(x, 2)));
      일사분면 += 최대y - 최소y + 1;
    }
  }

  answer += 일사분면 * 4;

  return answer;
}

/********************** 아래는 도전과 실패 사례 ******************/

/**
 * 문제 설명
 *
 * @param number r1 1보다 큰 자연수
 * @param number r2 r1보다 큰 자연수
 * @returns
 * 1차 시도: 테스트6까지는 통과했으나 테스트7부터 시간초과로 실패
 * 테스트 6: 통과 (20.11ms, 36.5MB)
 * 테스트 7부터: 실패 (시간 초과)
테스트 4 〉	통과 (9.12ms, 36.4MB)
테스트 5 〉	통과 (89.09ms, 36.4MB)
테스트 6 〉	통과 (20.38ms, 36.2MB)
 */
function solution(r1, r2) {
  var answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  // x, y좌표 둘 중 최소 하나가 r1보다 크거나 같고 r2보다 작거나 같아야함
  // 즉 x좌표 기준 -> x가 -r2 ~ -r1, r1에서 r2까지의 정수값을 가질 수 있고,
  // 이때 y는 0 ~ -r2 또는 0 ~ r2 사이의 값 중
  // (x, y)의 원점과의 거리값이 r1보다 크거나 같고 r2보다 작거나 같다는 조건을 만족해야함
  // 연산을 조금이라도 줄이기 위해서는 x 또는 y좌표가 0인 케이스를 분기해서 먼저 넣어두는 게 나을까? 아니면 같이 계산 돌리는 게 깔끔할까?
  // x좌표 기준으로 구하고 y좌표 기준으로 구해서 합칠 때 (x = y)인 점들은 중복으로 더해질 수 있다는 점 유의

  // 1. x축, y축 상에 위치하는 점들부터 구해서 넣기
  // answer += (r2 - r1 + 1) * 4;

  // 2. 1사분면과 2사분면에 있는 점들 중 x가 r1 ~ r2인 점들 구하기
  // let quaterOfX = 0;
  // for (let x = r1; x < r2; x++) {
  //     for (let y = 1; y < r2; y++) {
  //         if ( (x*x + y*y) <= r2*r2 ){
  //             quaterOfX++;
  //         }
  //     }
  // }
  // answer += quaterOfX*4;

  // let quaterOfY = 0;
  // for (let y = r1; y < r2; y++) {
  //     for (let x = 1; x < r2; x++) {
  //         if ( (x*x + y*y) <= r2*r2 && x !== y){
  //             quaterOfY++;
  //         }
  //     }
  // }
  // answer += quaterOfY*4;

  // 4개분면 대칭이므로 (x > 0인)x축 위의 점들 + 1사분면 위에 위치한 점들의 수를 구한 뒤 x4
  let 일사분면해당점개수 = 0;
  // y축 위 점들을 배제하기 위해 x는 1부터 시작
  for (let x = 1; x <= r2; x++) {
    // x축 위 점들을 포함하기 위해 y 0부터 시작, y=r2는 x>0일 때 틀리므로 배제
    for (let y = 0; y < r2; y++) {
      const 원점으로부터의거리의제곱 = x * x + y * y;
      if (
        원점으로부터의거리의제곱 <= r2 * r2 &&
        원점으로부터의거리의제곱 >= r1 * r1
      ) {
        일사분면해당점개수++;
      }
    }
  }
  answer += 일사분면해당점개수 * 4;

  return answer;
}

/**
 *
 * @param {*} r1
 * @param {*} r2
 * @returns
 * 2차 시도: 이건 더 오래걸림
 * 테스트 6: 1881ms (492MB)
 * 테스트 7부터: 실패 (signal: aborted (core dumped))
 */
function solution(r1, r2) {
  var answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  // 4개분면 대칭이므로 x축 위와 1사분면에 위치한 점들의 수를 구한 뒤 x4
  const xs = Array(r2)
    .fill()
    .map((v, i) => i + 1);
  const pointsForTestByX = xs.map((v) => {
    return Array(r2)
      .fill()
      .map((v2, i) => {
        return { x: v, y: i };
      });
  });
  const pointsForTest = pointsForTestByX.flat();

  const quaterOfCorrectPoints = pointsForTest.reduce((acc, cur) => {
    const theSquareOfDistanceFromOrigin = cur.x * cur.x + cur.y * cur.y;
    return (acc +=
      theSquareOfDistanceFromOrigin <= r2 * r2 &&
      theSquareOfDistanceFromOrigin >= r1 * r1
        ? 1
        : 0);
  }, 0);

  answer += quaterOfCorrectPoints * 4;

  return answer;
}

/**
 *
 * @param {*} r1
 * @param {*} r2
 * @returns
 * 3차시도: 계산을 조금이라도 줄였는데 실패
 * 테스트 4 〉	통과 (10.29ms, 36.4MB)
 * 테스트 5 〉	통과 (5.41ms, 35.3MB)
 * 테스트 6 〉	통과 (23.19ms, 35.3MB)
 * 1차시도때보다 느린 것 같지만 1차 시도 코드를 다시 복붙해서 넣으니까 이거보다 길게 나옴.. 서버상태가 안좋아졌나;
 */
function solution(r1, r2) {
  var answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  // 4개분면 대칭이므로 (x > 0인)x축 위의 점들 + 1사분면 위에 위치한 점들의 수를 구한 뒤 x4
  let 일사분면해당점개수 = r2 - r1 + 1; // x축 위의 점 개수 미리 계산해서 포함
  // y축 위 점들을 배제하기 위해 x는 1부터 시작, x=r2는 y=0일 때 뿐인데 이미 포함되었으므로 배제
  for (let x = 1; x < r2; x++) {
    // x축 위 점들은 이미 포함이므로 y 1부터 시작, y=r2는 x>0일 때 틀리므로 배제
    for (let y = 1; y < r2; y++) {
      const 원점으로부터의거리의제곱 = x * x + y * y;
      if (
        원점으로부터의거리의제곱 <= r2 * r2 &&
        원점으로부터의거리의제곱 >= r1 * r1
      ) {
        일사분면해당점개수++;
      }
    }
  }
  answer += 일사분면해당점개수 * 4;

  return answer;
}

function solution(r1, r2) {
  var answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  // 4개분면 대칭이므로 (x > 0인)x축 위의 점들 + 1사분면 위에 위치한 점들의 수를 구한 뒤 x4
  let 일사분면해당점개수 = r2 - r1 + 1; // x축 위의 점 개수 미리 계산해서 포함
  let 일사분면해당점개수의절반 = 0;
  // y축 위 점들을 배제하기 위해 x는 1부터 시작, x=r2는 y=0일 때 뿐인데 이미 포함되었으므로 배제
  for (let x = r1; x < r2; x++) {
    // x축 위 점들은 이미 포함이므로 y 1부터 시작, y=r2는 x>0일 때 틀리므로 배제
    for (let y = 1; y < r2; y++) {
      if (x === y) {
        const 원점으로부터의거리의제곱 = x * x + y * y;
        if (
          원점으로부터의거리의제곱 <= r2 * r2 &&
          원점으로부터의거리의제곱 >= r1 * r1
        ) {
          일사분면해당점개수의절반++;
        }
        continue;
      } else {
        const 원점으로부터의거리의제곱 = x * x + y * y;
        if (
          원점으로부터의거리의제곱 <= r2 * r2 &&
          원점으로부터의거리의제곱 >= r1 * r1
        ) {
          일사분면해당점개수의절반++;
        }
      }
    }
  }

  일사분면해당점개수 += 일사분면해당점개수의절반 * 2;
  answer += 일사분면해당점개수 * 4;

  return answer;
}

// 답도 틀리고 시간도 초과함
function solution(r1, r2) {
  var answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  // 4개분면 대칭이므로 (x > 0인)x축 위의 점들 + 1사분면 위에 위치한 점들의 수를 구한 뒤 x4
  let 일사분면해당점개수 = r2 - r1 + 1; // x축 위의 점 개수 미리 계산해서 포함
  let 일사분면해당점개수의절반 = 0;
  // y축 위 점들을 배제하기 위해 x는 1부터 시작, x=r2는 y=0일 때 뿐인데 이미 포함되었으므로 배제
  for (let x = r1; x < r2; x++) {
    // x축 위 점들은 이미 포함이므로 y 1부터 시작, y=r2는 x>0일 때 틀리므로 배제
    for (let y = 1; y <= x; y++) {
      // console.log(x, y);
      if (x === y) {
        const 원점으로부터의거리의제곱 = x * x + y * y;
        if (
          원점으로부터의거리의제곱 <= r2 * r2 &&
          원점으로부터의거리의제곱 >= r1 * r1
        ) {
          일사분면해당점개수++;
          // console.log("일사분면해당점개수: ", 일사분면해당점개수);
        }
      } else {
        const 원점으로부터의거리의제곱 = x * x + y * y;
        if (
          원점으로부터의거리의제곱 <= r2 * r2 &&
          원점으로부터의거리의제곱 >= r1 * r1
        ) {
          일사분면해당점개수의절반++;
          // console.log("일사분면해당점개수의절반: ", 일사분면해당점개수의절반);
        }
      }
    }
  }

  일사분면해당점개수 += 일사분면해당점개수의절반 * 2;
  answer += 일사분면해당점개수 * 4;

  return answer;
}

/**
 * 미묘하게 답이 다르게 나오네?
 * 다시 보니까 일관되게 정답보다 8개씩 크게 나온다? 만약 일사분면절반 계산에서 1 차이가 난다면 x8이므로 정확히 해당 차이가 발생함.
 * 아니면 x축/y축이나 x=y/x=-y 직선 위 점들을 계산하는 곳에서 2 정도의 차이가 발생하는 것일 가능성도 있음.
 * @param {*} r1 
 * @param {*} r2 
 * @returns 
 * 테스트 1
입력값 〉	2, 3
기댓값 〉	20
실행 결과 〉	테스트를 통과하였습니다.
테스트 2
입력값 〉	1, 100000
기댓값 〉	3141590520
실행 결과 〉	실행한 결괏값 31415925464이 기댓값 31415925456과 다릅니다.
테스트 3
입력값 〉	1, 10000
기댓값 〉	314159052
실행 결과 〉	실행한 결괏값 314159060이 기댓값 314159052과 다릅니다.
테스트 4
입력값 〉	1, 1000
기댓값 〉	3141548
실행 결과 〉	실행한 결괏값 3141556이 기댓값 3141548과 다릅니다.
테스트 5
입력값 〉	2, 4
기댓값 〉	40
실행 결과 〉	테스트를 통과하였습니다.

 * 야매로 8씩 크게 차이가 나는 걸 -8 로 깎아주고 돌려봤는데 그냥 다 실패인 데다 결국 테스트7 이상의 시간초과도 통과 못함
테스트 1 〉	실패 (0.08ms, 33.4MB)
테스트 2 〉	실패 (0.08ms, 33.4MB)
테스트 3 〉	실패 (0.20ms, 33.4MB)
테스트 4 〉	실패 (2.92ms, 36.3MB)
테스트 5 〉	실패 (2.63ms, 36.3MB)
테스트 6 〉	실패 (3.71ms, 36.3MB)
테스트 7 〉	실패 (시간 초과)
테스트 8 〉	실패 (시간 초과)
테스트 9 〉	실패 (시간 초과)
테스트 10 〉	실패 (시간 초과)
 * -8을 하지 않았을 때는 테스트 1은 통과함.. (어차피 테스트7부터는 10초 넘는 건 같음)
테스트 1 〉	통과 (0.08ms, 33.4MB)
테스트 2 〉	실패 (0.08ms, 33.4MB)
테스트 3 〉	실패 (0.17ms, 33.5MB)
테스트 4 〉	실패 (2.90ms, 36.2MB)
테스트 5 〉	실패 (2.66ms, 36.3MB)
테스트 6 〉	실패 (3.69ms, 36.2MB)
테스트 7 〉	실패 (시간 초과)
테스트 8 〉	실패 (시간 초과)
테스트 9 〉	실패 (시간 초과)
테스트 10 〉	실패 (시간 초과)
 */
// 다 계산할 필요가 없다. 큰 것들이 포함된다면 그보다 작은 것들은 당연히 포함, 제일 작은 것이 포함된다면 그보다 큰 것들은 당연히 포함되므로.
// x와 y가 반대인 조합은 중복으로 반복/계산할 필요가 없다.
function solution(r1, r2) {
  let answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  answer = (r2 - r1 + 1) * 4; // x축 y축 위에 있는 해당 점들은 먼저 더해놓기

  let 최소xy = 0;
  let 최대xy = 0;
  for (let x = r1; x < r2; x++) {
    const 원점으로부터의거리의제곱 = x * x + x * x;
    if (
      원점으로부터의거리의제곱 <= r2 * r2 &&
      원점으로부터의거리의제곱 >= r1 * r1
    ) {
      최소xy = x;
      break;
    }
  }
  for (let x = r2; x >= r1; x--) {
    const 원점으로부터의거리의제곱 = x * x + x * x;
    if (
      원점으로부터의거리의제곱 <= r2 * r2 &&
      원점으로부터의거리의제곱 >= r1 * r1
    ) {
      최대xy = x;
      break;
    }
  }
  // console.log(최대xy, 최소xy);
  answer += (최대xy - 최소xy + 1) * 4; // x = y, x = -y 직선 위의 해당 점 개수

  // 4개분면 대칭이므로 1사분면에 위치한 점들 절반의 수를 구한 뒤 x4
  let 일사분면절반 = 0;

  let 최소y = 0;
  let 최대y = 0;
  for (let x = r1; x < r2; x++) {
    // x축 위 점들은 이미 포함이므로 y 1부터 시작, y=r2는 x>0일 때 틀리므로 배제
    for (let y = 1; y < x; y++) {
      const 원점으로부터의거리의제곱 = x * x + y * y;
      if (
        원점으로부터의거리의제곱 <= r2 * r2 &&
        원점으로부터의거리의제곱 >= r1 * r1
      ) {
        최소y = y;
        break;
      }
    }
    for (let y = x - 1; y > 0; y--) {
      const 원점으로부터의거리의제곱 = x * x + y * y;
      if (
        원점으로부터의거리의제곱 <= r2 * r2 &&
        원점으로부터의거리의제곱 >= r1 * r1
      ) {
        최대y = y;
        break;
      }
    }
    일사분면절반 += 최대y - 최소y + 1;
  }

  answer += 일사분면절반 * 8;

  return answer;
}

/**
 * 위에서 8개로 분할계산해서 x8 하는 방법이 미묘하게 다르게 나와서 중복을 감수하고 4개로 분할계산해서 x4 하는 방법으로 한번 도전해봄
 * -> 답은 맞게 나오고 최초 방법보다는 빠르게 나오는데 테스트 7부터는 여전히 시간초과로 실패
 * @param {*} r1
 * @param {*} r2
 * @returns
 * 테스트 1 〉	통과 (0.08ms, 33.3MB)
테스트 2 〉	통과 (0.15ms, 33.4MB)
테스트 3 〉	통과 (0.16ms, 33.4MB)
테스트 4 〉	통과 (5.61ms, 36.3MB)
테스트 5 〉	통과 (2.96ms, 36.2MB)
테스트 6 〉	통과 (7.27ms, 36.3MB)
 */
// 다 계산할 필요가 없다. 큰 것들이 포함된다면 그보다 작은 것들은 당연히 포함, 제일 작은 것이 포함된다면 그보다 큰 것들은 당연히 포함되므로.
// x와 y가 반대인 조합은 중복으로 반복/계산할 필요가 없다. -> x8에서 x4로 돌아오면서 이 부분을 아직 해결 못함
function solution(r1, r2) {
  let answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  answer = (r2 - r1 + 1) * 4; // x축 y축 위에 있는 해당 점들은 먼저 더해놓기

  // 4개분면 대칭이므로 1사분면에 위치한 점들의 수를 구한 뒤 x4
  let 일사분면 = 0;

  let 최소y = 0;
  let 최대y = 0;
  for (let x = 1; x < r2; x++) {
    // x축 위 점들은 이미 포함이므로 y 1부터 시작, y=r2는 x>0일 때 틀리므로 배제
    for (let y = 1; y < r2; y++) {
      const 원점으로부터의거리의제곱 = x * x + y * y;
      if (
        원점으로부터의거리의제곱 <= r2 * r2 &&
        원점으로부터의거리의제곱 >= r1 * r1
      ) {
        최소y = y;
        break;
      }
    }
    for (let y = r2 - 1; y > 0; y--) {
      const 원점으로부터의거리의제곱 = x * x + y * y;
      if (
        원점으로부터의거리의제곱 <= r2 * r2 &&
        원점으로부터의거리의제곱 >= r1 * r1
      ) {
        최대y = y;
        break;
      }
    }
    일사분면 += 최대y - 최소y + 1;
  }

  answer += 일사분면 * 4;

  return answer;
}

/**
 * 전략을 바꿔보자. 생각해보니 1사분면에서 x를 1씩 증가시키면서 r2원 위의 점의 y값을 구하고
 * 해당 y값과 r1원 위의 점의 y값을 비교해서 그 사이의 정수값 갯수만 구하면 됨. 
 * 심지어 x가 r1보다 크면 그냥 그대로 개수이고!
 * @param {*} r1 
 * @param {*} r2 
 * @returns 
 * 테스트 1
입력값 〉	2, 3
기댓값 〉	20
실행 결과 〉	테스트를 통과하였습니다.
테스트 2
입력값 〉	3, 10000000
기댓값 〉	314159185350596
실행 결과 〉	테스트를 통과하였습니다. -> 이건 여기서 나온 값을 테스트케이스 정답으로 넣은 거라 의미는 없음
테스트 3
입력값 〉	1, 100000
기댓값 〉	31415925456
실행 결과 〉	테스트를 통과하였습니다.
테스트 4
입력값 〉	1, 10000
기댓값 〉	314159052
실행 결과 〉	테스트를 통과하였습니다.
테스트 5
입력값 〉	1, 1000
기댓값 〉	3141548
실행 결과 〉	테스트를 통과하였습니다.
테스트 6
입력값 〉	2, 4
기댓값 〉	40
실행 결과 〉	실행한 결괏값 36이 기댓값 40과 다릅니다.
 * 테스트 1 〉	실패 (0.07ms, 33.4MB)
테스트 2 〉	실패 (0.16ms, 33.4MB)
테스트 3 〉	실패 (0.20ms, 33.4MB)
테스트 4 〉	실패 (0.38ms, 33.6MB)
테스트 5 〉	실패 (0.27ms, 33.5MB)
테스트 6 〉	실패 (0.49ms, 33.4MB)
테스트 7 〉	실패 (6.83ms, 37.2MB)
테스트 8 〉	실패 (9.23ms, 37.3MB)
테스트 9 〉	실패 (7.27ms, 37.3MB)
테스트 10 〉	통과 (10.89ms, 37.7MB)
 */
function solution(r1, r2) {
  let answer = 0;
  if (r1 < 1 || r2 < r1) return 0;

  answer = (r2 - r1 + 1) * 4; // x축 y축 위에 있는 해당 점들은 먼저 더해놓기

  // 4개분면 대칭이므로 1사분면에 위치한 점들 수를 구한 뒤 x4
  let 일사분면 = 0;

  let 최대y = 0;
  let 최소y = 0;
  for (let x = 1; x < r2; x++) {
    최대y = Math.floor(Math.sqrt(Math.pow(r2, 2) - Math.pow(x, 2)));
    if (x >= r1) {
      일사분면 += 최대y;
    } else {
      최소y = 최대y = Math.floor(Math.sqrt(Math.pow(r1, 2) - Math.pow(x, 2)));
      일사분면 += 최대y - 최소y + 1;
    }
  }

  answer += 일사분면 * 4;

  return answer;
}
